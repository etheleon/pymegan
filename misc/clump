#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"File/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PATH';
  package File::Path;
  
  use 5.005_04;
  use strict;
  
  use Cwd 'getcwd';
  use File::Basename ();
  use File::Spec     ();
  
  BEGIN {
      if ( $] < 5.006 ) {
  
          # can't say 'opendir my $dh, $dirname'
          # need to initialise $dh
          eval 'use Symbol';
      }
  }
  
  use Exporter ();
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
  $VERSION   = '2.12';
  $VERSION   = eval $VERSION;
  @ISA       = qw(Exporter);
  @EXPORT    = qw(mkpath rmtree);
  @EXPORT_OK = qw(make_path remove_tree);
  
  BEGIN {
    for (qw(VMS MacOS MSWin32 os2)) {
      no strict 'refs';
      *{"_IS_\U$_"} = $^O eq $_ ? sub () { 1 } : sub () { 0 };
    }
  
    # These OSes complain if you want to remove a file that you have no
    # write permission to:
    *_FORCE_WRITABLE = (
      grep { $^O eq $_ } qw(amigaos dos epoc MSWin32 MacOS os2)
    ) ? sub () { 1 } : sub () { 0 };
  
    # Unix-like systems need to stat each directory in order to detect
    # race condition. MS-Windows is immune to this particular attack.
    *_NEED_STAT_CHECK = !(_IS_MSWIN32()) ? sub () { 1 } : sub () { 0 };
  }
  
  sub _carp {
      require Carp;
      goto &Carp::carp;
  }
  
  sub _croak {
      require Carp;
      goto &Carp::croak;
  }
  
  sub _error {
      my $arg     = shift;
      my $message = shift;
      my $object  = shift;
  
      if ( $arg->{error} ) {
          $object = '' unless defined $object;
          $message .= ": $!" if $!;
          push @{ ${ $arg->{error} } }, { $object => $message };
      }
      else {
          _carp( defined($object) ? "$message for $object: $!" : "$message: $!" );
      }
  }
  
  sub __is_arg {
      my ($arg) = @_;
  
      # If client code blessed an array ref to HASH, this will not work
      # properly. We could have done $arg->isa() wrapped in eval, but
      # that would be expensive. This implementation should suffice.
      # We could have also used Scalar::Util:blessed, but we choose not
      # to add this dependency
      return ( ref $arg eq 'HASH' );
  }
  
  sub make_path {
      push @_, {} unless @_ and __is_arg( $_[-1] );
      goto &mkpath;
  }
  
  sub mkpath {
      my $old_style = !( @_ and __is_arg( $_[-1] ) );
  
      my $arg;
      my $paths;
  
      if ($old_style) {
          my ( $verbose, $mode );
          ( $paths, $verbose, $mode ) = @_;
          $paths = [$paths] unless UNIVERSAL::isa( $paths, 'ARRAY' );
          $arg->{verbose} = $verbose;
          $arg->{mode} = defined $mode ? $mode : oct '777';
      }
      else {
          my %args_permitted = map { $_ => 1 } ( qw|
              chmod
              error
              group
              mask
              mode
              owner
              uid
              user
              verbose
          | );
          my @bad_args = ();
          $arg = pop @_;
          for my $k (sort keys %{$arg}) {
              push @bad_args, $k unless $args_permitted{$k};
          }
          _carp("Unrecognized option(s) passed to make_path(): @bad_args")
              if @bad_args;
          $arg->{mode} = delete $arg->{mask} if exists $arg->{mask};
          $arg->{mode} = oct '777' unless exists $arg->{mode};
          ${ $arg->{error} } = [] if exists $arg->{error};
          $arg->{owner} = delete $arg->{user} if exists $arg->{user};
          $arg->{owner} = delete $arg->{uid}  if exists $arg->{uid};
          if ( exists $arg->{owner} and $arg->{owner} =~ /\D/ ) {
              my $uid = ( getpwnam $arg->{owner} )[2];
              if ( defined $uid ) {
                  $arg->{owner} = $uid;
              }
              else {
                  _error( $arg,
  "unable to map $arg->{owner} to a uid, ownership not changed"
                  );
                  delete $arg->{owner};
              }
          }
          if ( exists $arg->{group} and $arg->{group} =~ /\D/ ) {
              my $gid = ( getgrnam $arg->{group} )[2];
              if ( defined $gid ) {
                  $arg->{group} = $gid;
              }
              else {
                  _error( $arg,
  "unable to map $arg->{group} to a gid, group ownership not changed"
                  );
                  delete $arg->{group};
              }
          }
          if ( exists $arg->{owner} and not exists $arg->{group} ) {
              $arg->{group} = -1;    # chown will leave group unchanged
          }
          if ( exists $arg->{group} and not exists $arg->{owner} ) {
              $arg->{owner} = -1;    # chown will leave owner unchanged
          }
          $paths = [@_];
      }
      return _mkpath( $arg, $paths );
  }
  
  sub _mkpath {
      my $arg   = shift;
      my $paths = shift;
  
      my ( @created );
      foreach my $path ( @{$paths} ) {
          next unless defined($path) and length($path);
          $path .= '/' if _IS_OS2 and $path =~ /^\w:\z/s; # feature of CRT
  
          # Logic wants Unix paths, so go with the flow.
          if (_IS_VMS) {
              next if $path eq '/';
              $path = VMS::Filespec::unixify($path);
          }
          next if -d $path;
          my $parent = File::Basename::dirname($path);
          unless ( -d $parent or $path eq $parent ) {
              push( @created, _mkpath( $arg, [$parent] ) );
          }
          print "mkdir $path\n" if $arg->{verbose};
          if ( mkdir( $path, $arg->{mode} ) ) {
              push( @created, $path );
              if ( exists $arg->{owner} ) {
  
                  # NB: $arg->{group} guaranteed to be set during initialisation
                  if ( !chown $arg->{owner}, $arg->{group}, $path ) {
                      _error( $arg,
  "Cannot change ownership of $path to $arg->{owner}:$arg->{group}"
                      );
                  }
              }
              if ( exists $arg->{chmod} ) {
                  if ( !chmod $arg->{chmod}, $path ) {
                      _error( $arg,
                          "Cannot change permissions of $path to $arg->{chmod}" );
                  }
              }
          }
          else {
              my $save_bang = $!;
              my ( $e, $e1 ) = ( $save_bang, $^E );
              $e .= "; $e1" if $e ne $e1;
  
              # allow for another process to have created it meanwhile
              if ( ! -d $path ) {
                  $! = $save_bang;
                  if ( $arg->{error} ) {
                      push @{ ${ $arg->{error} } }, { $path => $e };
                  }
                  else {
                      _croak("mkdir $path: $e");
                  }
              }
          }
      }
      return @created;
  }
  
  sub remove_tree {
      push @_, {} unless @_ and __is_arg( $_[-1] );
      goto &rmtree;
  }
  
  sub _is_subdir {
      my ( $dir, $test ) = @_;
  
      my ( $dv, $dd ) = File::Spec->splitpath( $dir,  1 );
      my ( $tv, $td ) = File::Spec->splitpath( $test, 1 );
  
      # not on same volume
      return 0 if $dv ne $tv;
  
      my @d = File::Spec->splitdir($dd);
      my @t = File::Spec->splitdir($td);
  
      # @t can't be a subdir if it's shorter than @d
      return 0 if @t < @d;
  
      return join( '/', @d ) eq join( '/', splice @t, 0, +@d );
  }
  
  sub rmtree {
      my $old_style = !( @_ and __is_arg( $_[-1] ) );
  
      my $arg;
      my $paths;
  
      if ($old_style) {
          my ( $verbose, $safe );
          ( $paths, $verbose, $safe ) = @_;
          $arg->{verbose} = $verbose;
          $arg->{safe} = defined $safe ? $safe : 0;
  
          if ( defined($paths) and length($paths) ) {
              $paths = [$paths] unless UNIVERSAL::isa( $paths, 'ARRAY' );
          }
          else {
              _carp("No root path(s) specified\n");
              return 0;
          }
      }
      else {
          my %args_permitted = map { $_ => 1 } ( qw|
              error
              keep_root
              result
              safe
              verbose
          | );
          my @bad_args = ();
          $arg = pop @_;
          for my $k (sort keys %{$arg}) {
              push @bad_args, $k unless $args_permitted{$k};
          }
          _carp("Unrecognized option(s) passed to remove_tree(): @bad_args")
              if @bad_args;
          ${ $arg->{error} }  = [] if exists $arg->{error};
          ${ $arg->{result} } = [] if exists $arg->{result};
          $paths = [@_];
      }
  
      $arg->{prefix} = '';
      $arg->{depth}  = 0;
  
      my @clean_path;
      $arg->{cwd} = getcwd() or do {
          _error( $arg, "cannot fetch initial working directory" );
          return 0;
      };
      for ( $arg->{cwd} ) { /\A(.*)\Z/s; $_ = $1 }    # untaint
  
      for my $p (@$paths) {
  
          # need to fixup case and map \ to / on Windows
          my $ortho_root = _IS_MSWIN32 ? _slash_lc($p) : $p;
          my $ortho_cwd =
            _IS_MSWIN32 ? _slash_lc( $arg->{cwd} ) : $arg->{cwd};
          my $ortho_root_length = length($ortho_root);
          $ortho_root_length-- if _IS_VMS;   # don't compare '.' with ']'
          if ( $ortho_root_length && _is_subdir( $ortho_root, $ortho_cwd ) ) {
              local $! = 0;
              _error( $arg, "cannot remove path when cwd is $arg->{cwd}", $p );
              next;
          }
  
          if (_IS_MACOS) {
              $p = ":$p" unless $p =~ /:/;
              $p .= ":" unless $p =~ /:\z/;
          }
          elsif ( _IS_MSWIN32 ) {
              $p =~ s{[/\\]\z}{};
          }
          else {
              $p =~ s{/\z}{};
          }
          push @clean_path, $p;
      }
  
      @{$arg}{qw(device inode perm)} = ( lstat $arg->{cwd} )[ 0, 1 ] or do {
          _error( $arg, "cannot stat initial working directory", $arg->{cwd} );
          return 0;
      };
  
      return _rmtree( $arg, \@clean_path );
  }
  
  sub _rmtree {
      my $arg   = shift;
      my $paths = shift;
  
      my $count  = 0;
      my $curdir = File::Spec->curdir();
      my $updir  = File::Spec->updir();
  
      my ( @files, $root );
    ROOT_DIR:
      foreach my $root (@$paths) {
  
          # since we chdir into each directory, it may not be obvious
          # to figure out where we are if we generate a message about
          # a file name. We therefore construct a semi-canonical
          # filename, anchored from the directory being unlinked (as
          # opposed to being truly canonical, anchored from the root (/).
  
          my $canon =
            $arg->{prefix}
            ? File::Spec->catfile( $arg->{prefix}, $root )
            : $root;
  
          my ( $ldev, $lino, $perm ) = ( lstat $root )[ 0, 1, 2 ]
            or next ROOT_DIR;
  
          if ( -d _ ) {
              $root = VMS::Filespec::vmspath( VMS::Filespec::pathify($root) )
                if _IS_VMS;
  
              if ( !chdir($root) ) {
  
                  # see if we can escalate privileges to get in
                  # (e.g. funny protection mask such as -w- instead of rwx)
                  $perm &= oct '7777';
                  my $nperm = $perm | oct '700';
                  if (
                      !(
                             $arg->{safe}
                          or $nperm == $perm
                          or chmod( $nperm, $root )
                      )
                    )
                  {
                      _error( $arg,
                          "cannot make child directory read-write-exec", $canon );
                      next ROOT_DIR;
                  }
                  elsif ( !chdir($root) ) {
                      _error( $arg, "cannot chdir to child", $canon );
                      next ROOT_DIR;
                  }
              }
  
              my ( $cur_dev, $cur_inode, $perm ) = ( stat $curdir )[ 0, 1, 2 ]
                or do {
                  _error( $arg, "cannot stat current working directory", $canon );
                  next ROOT_DIR;
                };
  
              if (_NEED_STAT_CHECK) {
                  ( $ldev eq $cur_dev and $lino eq $cur_inode )
                    or _croak(
  "directory $canon changed before chdir, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting."
                    );
              }
  
              $perm &= oct '7777';    # don't forget setuid, setgid, sticky bits
              my $nperm = $perm | oct '700';
  
              # notabene: 0700 is for making readable in the first place,
              # it's also intended to change it to writable in case we have
              # to recurse in which case we are better than rm -rf for
              # subtrees with strange permissions
  
              if (
                  !(
                         $arg->{safe}
                      or $nperm == $perm
                      or chmod( $nperm, $curdir )
                  )
                )
              {
                  _error( $arg, "cannot make directory read+writeable", $canon );
                  $nperm = $perm;
              }
  
              my $d;
              $d = gensym() if $] < 5.006;
              if ( !opendir $d, $curdir ) {
                  _error( $arg, "cannot opendir", $canon );
                  @files = ();
              }
              else {
                  if ( !defined ${^TAINT} or ${^TAINT} ) {
                      # Blindly untaint dir names if taint mode is active
                      @files = map { /\A(.*)\z/s; $1 } readdir $d;
                  }
                  else {
                      @files = readdir $d;
                  }
                  closedir $d;
              }
  
              if (_IS_VMS) {
  
                  # Deleting large numbers of files from VMS Files-11
                  # filesystems is faster if done in reverse ASCIIbetical order.
                  # include '.' to '.;' from blead patch #31775
                  @files = map { $_ eq '.' ? '.;' : $_ } reverse @files;
              }
  
              @files = grep { $_ ne $updir and $_ ne $curdir } @files;
  
              if (@files) {
  
                  # remove the contained files before the directory itself
                  my $narg = {%$arg};
                  @{$narg}{qw(device inode cwd prefix depth)} =
                    ( $cur_dev, $cur_inode, $updir, $canon, $arg->{depth} + 1 );
                  $count += _rmtree( $narg, \@files );
              }
  
              # restore directory permissions of required now (in case the rmdir
              # below fails), while we are still in the directory and may do so
              # without a race via '.'
              if ( $nperm != $perm and not chmod( $perm, $curdir ) ) {
                  _error( $arg, "cannot reset chmod", $canon );
              }
  
              # don't leave the client code in an unexpected directory
              chdir( $arg->{cwd} )
                or
                _croak("cannot chdir to $arg->{cwd} from $canon: $!, aborting.");
  
              # ensure that a chdir upwards didn't take us somewhere other
              # than we expected (see CVE-2002-0435)
              ( $cur_dev, $cur_inode ) = ( stat $curdir )[ 0, 1 ]
                or _croak(
                  "cannot stat prior working directory $arg->{cwd}: $!, aborting."
                );
  
              if (_NEED_STAT_CHECK) {
                  ( $arg->{device} eq $cur_dev and $arg->{inode} eq $cur_inode )
                    or _croak(  "previous directory $arg->{cwd} "
                              . "changed before entering $canon, "
                              . "expected dev=$ldev ino=$lino, "
                              . "actual dev=$cur_dev ino=$cur_inode, aborting."
                    );
              }
  
              if ( $arg->{depth} or !$arg->{keep_root} ) {
                  if ( $arg->{safe}
                      && ( _IS_VMS
                          ? !&VMS::Filespec::candelete($root)
                          : !-w $root ) )
                  {
                      print "skipped $root\n" if $arg->{verbose};
                      next ROOT_DIR;
                  }
                  if ( _FORCE_WRITABLE and !chmod $perm | oct '700', $root ) {
                      _error( $arg, "cannot make directory writeable", $canon );
                  }
                  print "rmdir $root\n" if $arg->{verbose};
                  if ( rmdir $root ) {
                      push @{ ${ $arg->{result} } }, $root if $arg->{result};
                      ++$count;
                  }
                  else {
                      _error( $arg, "cannot remove directory", $canon );
                      if (
                          _FORCE_WRITABLE
                          && !chmod( $perm,
                              ( _IS_VMS ? VMS::Filespec::fileify($root) : $root )
                          )
                        )
                      {
                          _error(
                              $arg,
                              sprintf( "cannot restore permissions to 0%o",
                                  $perm ),
                              $canon
                          );
                      }
                  }
              }
          }
          else {
              # not a directory
              $root = VMS::Filespec::vmsify("./$root")
                if _IS_VMS
                && !File::Spec->file_name_is_absolute($root)
                && ( $root !~ m/(?<!\^)[\]>]+/ );    # not already in VMS syntax
  
              if (
                  $arg->{safe}
                  && (
                      _IS_VMS
                      ? !&VMS::Filespec::candelete($root)
                      : !( -l $root || -w $root )
                  )
                )
              {
                  print "skipped $root\n" if $arg->{verbose};
                  next ROOT_DIR;
              }
  
              my $nperm = $perm & oct '7777' | oct '600';
              if (    _FORCE_WRITABLE
                  and $nperm != $perm
                  and not chmod $nperm, $root )
              {
                  _error( $arg, "cannot make file writeable", $canon );
              }
              print "unlink $canon\n" if $arg->{verbose};
  
              # delete all versions under VMS
              for ( ; ; ) {
                  if ( unlink $root ) {
                      push @{ ${ $arg->{result} } }, $root if $arg->{result};
                  }
                  else {
                      _error( $arg, "cannot unlink file", $canon );
                      _FORCE_WRITABLE and chmod( $perm, $root )
                        or _error( $arg,
                          sprintf( "cannot restore permissions to 0%o", $perm ),
                          $canon );
                      last;
                  }
                  ++$count;
                  last unless _IS_VMS && lstat $root;
              }
          }
      }
      return $count;
  }
  
  sub _slash_lc {
  
      # fix up slashes and case on MSWin32 so that we can determine that
      # c:\path\to\dir is underneath C:/Path/To
      my $path = shift;
      $path =~ tr{\\}{/};
      return lc($path);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Path - Create or remove directory trees
  
  =head1 VERSION
  
  This document describes version 2.12 of File::Path.
  
  =head1 SYNOPSIS
  
    use File::Path qw(make_path remove_tree);
  
    @created = make_path('foo/bar/baz', '/zug/zwang');
    @created = make_path('foo/bar/baz', '/zug/zwang', {
        verbose => 1,
        mode => 0711,
    });
    make_path('foo/bar/baz', '/zug/zwang', {
        chmod => 0777,
    });
  
    $removed_count = remove_tree('foo/bar/baz', '/zug/zwang');
    $removed_count = remove_tree('foo/bar/baz', '/zug/zwang', {
        verbose => 1,
        error  => \my $err_list,
    });
  
    # legacy (interface promoted before v2.00)
    @created = mkpath('/foo/bar/baz');
    @created = mkpath('/foo/bar/baz', 1, 0711);
    @created = mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);
    $removed_count = rmtree('foo/bar/baz', 1, 1);
    $removed_count = rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);
  
    # legacy (interface promoted before v2.06)
    @created = mkpath('foo/bar/baz', '/zug/zwang', { verbose => 1, mode => 0711 });
    $removed_count = rmtree('foo/bar/baz', '/zug/zwang', { verbose => 1, mode => 0711 });
  
  =head1 DESCRIPTION
  
  This module provide a convenient way to create directories of
  arbitrary depth and to delete an entire directory subtree from the
  filesystem.
  
  The following functions are provided:
  
  =over
  
  =item make_path( $dir1, $dir2, .... )
  
  =item make_path( $dir1, $dir2, ...., \%opts )
  
  The C<make_path> function creates the given directories if they don't
  exists before, much like the Unix command C<mkdir -p>.
  
  The function accepts a list of directories to be created. Its
  behaviour may be tuned by an optional hashref appearing as the last
  parameter on the call.
  
  The function returns the list of directories actually created during
  the call; in scalar context the number of directories created.
  
  The following keys are recognised in the option hash:
  
  =over
  
  =item mode => $num
  
  The numeric permissions mode to apply to each created directory
  (defaults to 0777), to be modified by the current C<umask>. If the
  directory already exists (and thus does not need to be created),
  the permissions will not be modified.
  
  C<mask> is recognised as an alias for this parameter.
  
  =item chmod => $num
  
  Takes a numeric mode to apply to each created directory (not
  modified by the current C<umask>). If the directory already exists
  (and thus does not need to be created), the permissions will
  not be modified.
  
  =item verbose => $bool
  
  If present, will cause C<make_path> to print the name of each directory
  as it is created. By default nothing is printed.
  
  =item error => \$err
  
  If present, it should be a reference to a scalar.
  This scalar will be made to reference an array, which will
  be used to store any errors that are encountered.  See the L</"ERROR
  HANDLING"> section for more information.
  
  If this parameter is not used, certain error conditions may raise
  a fatal error that will cause the program to halt, unless trapped
  in an C<eval> block.
  
  =item owner => $owner
  
  =item user => $owner
  
  =item uid => $owner
  
  If present, will cause any created directory to be owned by C<$owner>.
  If the value is numeric, it will be interpreted as a uid, otherwise
  as username is assumed. An error will be issued if the username cannot be
  mapped to a uid, or the uid does not exist, or the process lacks the
  privileges to change ownership.
  
  Ownership of directories that already exist will not be changed.
  
  C<user> and C<uid> are aliases of C<owner>.
  
  =item group => $group
  
  If present, will cause any created directory to be owned by the group C<$group>.
  If the value is numeric, it will be interpreted as a gid, otherwise
  as group name is assumed. An error will be issued if the group name cannot be
  mapped to a gid, or the gid does not exist, or the process lacks the
  privileges to change group ownership.
  
  Group ownership of directories that already exist will not be changed.
  
      make_path '/var/tmp/webcache', {owner=>'nobody', group=>'nogroup'};
  
  =back
  
  =item mkpath( $dir )
  
  =item mkpath( $dir, $verbose, $mode )
  
  =item mkpath( [$dir1, $dir2,...], $verbose, $mode )
  
  =item mkpath( $dir1, $dir2,..., \%opt )
  
  The mkpath() function provide the legacy interface of make_path() with
  a different interpretation of the arguments passed.  The behaviour and
  return value of the function is otherwise identical to make_path().
  
  =item remove_tree( $dir1, $dir2, .... )
  
  =item remove_tree( $dir1, $dir2, ...., \%opts )
  
  The C<remove_tree> function deletes the given directories and any
  files and subdirectories they might contain, much like the Unix
  command C<rm -r> or the Windows commands C<rmdir /s> and C<rd /s>. The
  only exception to the function similarity is C<remove_tree> accepts
  only directories whereas C<rm -r> also accepts files.
  
  The function accepts a list of directories to be
  removed. Its behaviour may be tuned by an optional hashref
  appearing as the last parameter on the call.  If an empty string is
  passed to C<remove_tree>, an error will occur.
  
  The functions returns the number of files successfully deleted.
  
  The following keys are recognised in the option hash:
  
  =over
  
  =item verbose => $bool
  
  If present, will cause C<remove_tree> to print the name of each file as
  it is unlinked. By default nothing is printed.
  
  =item safe => $bool
  
  When set to a true value, will cause C<remove_tree> to skip the files
  for which the process lacks the required privileges needed to delete
  files, such as delete privileges on VMS. In other words, the code
  will make no attempt to alter file permissions. Thus, if the process
  is interrupted, no filesystem object will be left in a more
  permissive mode.
  
  =item keep_root => $bool
  
  When set to a true value, will cause all files and subdirectories
  to be removed, except the initially specified directories. This comes
  in handy when cleaning out an application's scratch directory.
  
    remove_tree( '/tmp', {keep_root => 1} );
  
  =item result => \$res
  
  If present, it should be a reference to a scalar.
  This scalar will be made to reference an array, which will
  be used to store all files and directories unlinked
  during the call. If nothing is unlinked, the array will be empty.
  
    remove_tree( '/tmp', {result => \my $list} );
    print "unlinked $_\n" for @$list;
  
  This is a useful alternative to the C<verbose> key.
  
  =item error => \$err
  
  If present, it should be a reference to a scalar.
  This scalar will be made to reference an array, which will
  be used to store any errors that are encountered.  See the L</"ERROR
  HANDLING"> section for more information.
  
  Removing things is a much more dangerous proposition than
  creating things. As such, there are certain conditions that
  C<remove_tree> may encounter that are so dangerous that the only
  sane action left is to kill the program.
  
  Use C<error> to trap all that is reasonable (problems with
  permissions and the like), and let it die if things get out
  of hand. This is the safest course of action.
  
  =back
  
  =item rmtree( $dir )
  
  =item rmtree( $dir, $verbose, $safe )
  
  =item rmtree( [$dir1, $dir2,...], $verbose, $safe )
  
  =item rmtree( $dir1, $dir2,..., \%opt )
  
  The rmtree() function provide the legacy interface of remove_tree()
  with a different interpretation of the arguments passed. The behaviour
  and return value of the function is otherwise identical to
  remove_tree().
  
  =back
  
  =head2 ERROR HANDLING
  
  =over 4
  
  =item B<NOTE:>
  
  The following error handling mechanism is consistent throughout all
  code paths EXCEPT in cases where the ROOT node is nonexistent.  In
  version 2.11 the maintainers attempted to rectify this inconsistency
  but too many downstream modules encountered problems.  In such case,
  if you require root node evaluation or error checking prior to calling
  C<make_path> or C<remove_tree>, you should take additional precautions.
  
  =back
  
  If C<make_path> or C<remove_tree> encounter an error, a diagnostic
  message will be printed to C<STDERR> via C<carp> (for non-fatal
  errors), or via C<croak> (for fatal errors).
  
  If this behaviour is not desirable, the C<error> attribute may be
  used to hold a reference to a variable, which will be used to store
  the diagnostics. The variable is made a reference to an array of hash
  references.  Each hash contain a single key/value pair where the key
  is the name of the file, and the value is the error message (including
  the contents of C<$!> when appropriate).  If a general error is
  encountered the diagnostic key will be empty.
  
  An example usage looks like:
  
    remove_tree( 'foo/bar', 'bar/rat', {error => \my $err} );
    if (@$err) {
        for my $diag (@$err) {
            my ($file, $message) = %$diag;
            if ($file eq '') {
                print "general error: $message\n";
            }
            else {
                print "problem unlinking $file: $message\n";
            }
        }
    }
    else {
        print "No error encountered\n";
    }
  
  Note that if no errors are encountered, C<$err> will reference an
  empty array.  This means that C<$err> will always end up TRUE; so you
  need to test C<@$err> to determine if errors occurred.
  
  =head2 NOTES
  
  C<File::Path> blindly exports C<mkpath> and C<rmtree> into the
  current namespace. These days, this is considered bad style, but
  to change it now would break too much code. Nonetheless, you are
  invited to specify what it is you are expecting to use:
  
    use File::Path 'rmtree';
  
  The routines C<make_path> and C<remove_tree> are B<not> exported
  by default. You must specify which ones you want to use.
  
    use File::Path 'remove_tree';
  
  Note that a side-effect of the above is that C<mkpath> and C<rmtree>
  are no longer exported at all. This is due to the way the C<Exporter>
  module works. If you are migrating a codebase to use the new
  interface, you will have to list everything explicitly. But that's
  just good practice anyway.
  
    use File::Path qw(remove_tree rmtree);
  
  =head3 API CHANGES
  
  The API was changed in the 2.0 branch. For a time, C<mkpath> and
  C<rmtree> tried, unsuccessfully, to deal with the two different
  calling mechanisms. This approach was considered a failure.
  
  The new semantics are now only available with C<make_path> and
  C<remove_tree>. The old semantics are only available through
  C<mkpath> and C<rmtree>. Users are strongly encouraged to upgrade
  to at least 2.08 in order to avoid surprises.
  
  =head3 SECURITY CONSIDERATIONS
  
  There were race conditions 1.x implementations of File::Path's
  C<rmtree> function (although sometimes patched depending on the OS
  distribution or platform). The 2.0 version contains code to avoid the
  problem mentioned in CVE-2002-0435.
  
  See the following pages for more information:
  
    http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=286905
    http://www.nntp.perl.org/group/perl.perl5.porters/2005/01/msg97623.html
    http://www.debian.org/security/2005/dsa-696
  
  Additionally, unless the C<safe> parameter is set (or the
  third parameter in the traditional interface is TRUE), should a
  C<remove_tree> be interrupted, files that were originally in read-only
  mode may now have their permissions set to a read-write (or "delete
  OK") mode.
  
  =head1 DIAGNOSTICS
  
  FATAL errors will cause the program to halt (C<croak>), since the
  problem is so severe that it would be dangerous to continue. (This
  can always be trapped with C<eval>, but it's not a good idea. Under
  the circumstances, dying is the best thing to do).
  
  SEVERE errors may be trapped using the modern interface. If the
  they are not trapped, or the old interface is used, such an error
  will cause the program will halt.
  
  All other errors may be trapped using the modern interface, otherwise
  they will be C<carp>ed about. Program execution will not be halted.
  
  =over 4
  
  =item mkdir [path]: [errmsg] (SEVERE)
  
  C<make_path> was unable to create the path. Probably some sort of
  permissions error at the point of departure, or insufficient resources
  (such as free inodes on Unix).
  
  =item No root path(s) specified
  
  C<make_path> was not given any paths to create. This message is only
  emitted if the routine is called with the traditional interface.
  The modern interface will remain silent if given nothing to do.
  
  =item No such file or directory
  
  On Windows, if C<make_path> gives you this warning, it may mean that
  you have exceeded your filesystem's maximum path length.
  
  =item cannot fetch initial working directory: [errmsg]
  
  C<remove_tree> attempted to determine the initial directory by calling
  C<Cwd::getcwd>, but the call failed for some reason. No attempt
  will be made to delete anything.
  
  =item cannot stat initial working directory: [errmsg]
  
  C<remove_tree> attempted to stat the initial directory (after having
  successfully obtained its name via C<getcwd>), however, the call
  failed for some reason. No attempt will be made to delete anything.
  
  =item cannot chdir to [dir]: [errmsg]
  
  C<remove_tree> attempted to set the working directory in order to
  begin deleting the objects therein, but was unsuccessful. This is
  usually a permissions issue. The routine will continue to delete
  other things, but this directory will be left intact.
  
  =item directory [dir] changed before chdir, expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)
  
  C<remove_tree> recorded the device and inode of a directory, and then
  moved into it. It then performed a C<stat> on the current directory
  and detected that the device and inode were no longer the same. As
  this is at the heart of the race condition problem, the program
  will die at this point.
  
  =item cannot make directory [dir] read+writeable: [errmsg]
  
  C<remove_tree> attempted to change the permissions on the current directory
  to ensure that subsequent unlinkings would not run into problems,
  but was unable to do so. The permissions remain as they were, and
  the program will carry on, doing the best it can.
  
  =item cannot read [dir]: [errmsg]
  
  C<remove_tree> tried to read the contents of the directory in order
  to acquire the names of the directory entries to be unlinked, but
  was unsuccessful. This is usually a permissions issue. The
  program will continue, but the files in this directory will remain
  after the call.
  
  =item cannot reset chmod [dir]: [errmsg]
  
  C<remove_tree>, after having deleted everything in a directory, attempted
  to restore its permissions to the original state but failed. The
  directory may wind up being left behind.
  
  =item cannot remove [dir] when cwd is [dir]
  
  The current working directory of the program is F</some/path/to/here>
  and you are attempting to remove an ancestor, such as F</some/path>.
  The directory tree is left untouched.
  
  The solution is to C<chdir> out of the child directory to a place
  outside the directory tree to be removed.
  
  =item cannot chdir to [parent-dir] from [child-dir]: [errmsg], aborting. (FATAL)
  
  C<remove_tree>, after having deleted everything and restored the permissions
  of a directory, was unable to chdir back to the parent. The program
  halts to avoid a race condition from occurring.
  
  =item cannot stat prior working directory [dir]: [errmsg], aborting. (FATAL)
  
  C<remove_tree> was unable to stat the parent directory after have returned
  from the child. Since there is no way of knowing if we returned to
  where we think we should be (by comparing device and inode) the only
  way out is to C<croak>.
  
  =item previous directory [parent-dir] changed before entering [child-dir], expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)
  
  When C<remove_tree> returned from deleting files in a child directory, a
  check revealed that the parent directory it returned to wasn't the one
  it started out from. This is considered a sign of malicious activity.
  
  =item cannot make directory [dir] writeable: [errmsg]
  
  Just before removing a directory (after having successfully removed
  everything it contained), C<remove_tree> attempted to set the permissions
  on the directory to ensure it could be removed and failed. Program
  execution continues, but the directory may possibly not be deleted.
  
  =item cannot remove directory [dir]: [errmsg]
  
  C<remove_tree> attempted to remove a directory, but failed. This may because
  some objects that were unable to be removed remain in the directory, or
  a permissions issue. The directory will be left behind.
  
  =item cannot restore permissions of [dir] to [0nnn]: [errmsg]
  
  After having failed to remove a directory, C<remove_tree> was unable to
  restore its permissions from a permissive state back to a possibly
  more restrictive setting. (Permissions given in octal).
  
  =item cannot make file [file] writeable: [errmsg]
  
  C<remove_tree> attempted to force the permissions of a file to ensure it
  could be deleted, but failed to do so. It will, however, still attempt
  to unlink the file.
  
  =item cannot unlink file [file]: [errmsg]
  
  C<remove_tree> failed to remove a file. Probably a permissions issue.
  
  =item cannot restore permissions of [file] to [0nnn]: [errmsg]
  
  After having failed to remove a file, C<remove_tree> was also unable
  to restore the permissions on the file to a possibly less permissive
  setting. (Permissions given in octal).
  
  =item unable to map [owner] to a uid, ownership not changed");
  
  C<make_path> was instructed to give the ownership of created
  directories to the symbolic name [owner], but C<getpwnam> did
  not return the corresponding numeric uid. The directory will
  be created, but ownership will not be changed.
  
  =item unable to map [group] to a gid, group ownership not changed
  
  C<make_path> was instructed to give the group ownership of created
  directories to the symbolic name [group], but C<getgrnam> did
  not return the corresponding numeric gid. The directory will
  be created, but group ownership will not be changed.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<File::Remove>
  
  Allows files and directories to be moved to the Trashcan/Recycle
  Bin (where they may later be restored if necessary) if the operating
  system supports such functionality. This feature may one day be
  made available directly in C<File::Path>.
  
  =item *
  
  L<File::Find::Rule>
  
  When removing directory trees, if you want to examine each file to
  decide whether to delete it (and possibly leaving large swathes
  alone), F<File::Find::Rule> offers a convenient and flexible approach
  to examining directory trees.
  
  =back
  
  =head1 BUGS AND LIMITATIONS
  
  The following describes F<File::Path> limitations and how to report bugs.
  
  =head2 MULTITHREAD APPLICATIONS
  
  F<File::Path> B<rmtree> and B<remove_tree> will not work with multithreaded
  applications due to its use of B<chdir>.  At this time, no warning or error
  results and you will certainly encounter unexpected results.
  
  The implementation that surfaces this limitation may change in a future
  release.
  
  =head2 NFS Mount Points
  
  F<File::Path> is not responsible for triggering the automounts, mirror mounts,
  and the contents of network mounted filesystems.  If your NFS implementation
  requires an action to be performed on the filesystem in order for
  F<File::Path> to perform operations, it is strongly suggested you assure
  filesystem availability by reading the root of the mounted filesystem.
  
  =head2 REPORTING BUGS
  
  Please report all bugs on the RT queue, either via the web interface:
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=File-Path>
  
  or by email:
  
      bug-File-Path@rt.cpan.org
  
  In either case, please B<attach> patches to the bug report rather than
  including them inline in the web post or the body of the email.
  
  You can also send pull requests to the Github repository:
  
  L<https://github.com/rpcme/File-Path>
  
  =head1 ACKNOWLEDGEMENTS
  
  Paul Szabo identified the race condition originally, and Brendan
  O'Dea wrote an implementation for Debian that addressed the problem.
  That code was used as a basis for the current code. Their efforts
  are greatly appreciated.
  
  Gisle Aas made a number of improvements to the documentation for
  2.07 and his advice and assistance is also greatly appreciated.
  
  =head1 AUTHORS
  
  Prior authors and maintainers: Tim Bunce, Charles Bailey, and
  David Landgren <F<david@landgren.net>>.
  
  Current maintainers are Richard Elberger <F<riche@cpan.org>> and
  James (Jim) Keenan <F<jkeenan@cpan.org>>.
  
  =head1 CONTRIBUTORS
  
  Contributors to File::Path, in alphabetical order.
  
  =over 1
  
  =item <F<bulkdd@cpan.org>>
  
  =item Craig A. Berry <F<craigberry@mac.com>>
  
  =item Richard Elberger <F<riche@cpan.org>>
  
  =item Ryan Yee <F<ryee@cpan.org>>
  
  =item Skye Shaw <F<shaw@cpan.org>>
  
  =item Tom Lutz <F<tommylutz@gmail.com>>
  
  =back
  
  =head1 COPYRIGHT
  
  This module is copyright (C) Charles Bailey, Tim Bunce, David Landgren,
  James Keenan, and Richard Elberger 1995-2015. All rights reserved.
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_PATH

$fatpacked{"Parallel/ForkManager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARALLEL_FORKMANAGER';
  =head1 NAME
  
  Parallel::ForkManager - A simple parallel processing fork manager
  
  =head1 SYNOPSIS
  
    use Parallel::ForkManager;
  
    my $pm = Parallel::ForkManager->new($MAX_PROCESSES);
  
    DATA_LOOP:
    foreach my $data (@all_data) {
      # Forks and returns the pid for the child:
      my $pid = $pm->start and next DATA_LOOP;
  
      ... do some work with $data in the child process ...
  
      $pm->finish; # Terminates the child process
    }
  
  =head1 DESCRIPTION
  
  This module is intended for use in operations that can be done in parallel
  where the number of processes to be forked off should be limited. Typical
  use is a downloader which will be retrieving hundreds/thousands of files.
  
  The code for a downloader would look something like this:
  
    use LWP::Simple;
    use Parallel::ForkManager;
  
    ...
  
    my @links=(
      ["http://www.foo.bar/rulez.data","rulez_data.txt"],
      ["http://new.host/more_data.doc","more_data.doc"],
      ...
    );
  
    ...
  
    # Max 30 processes for parallel download
    my $pm = Parallel::ForkManager->new(30);
  
    LINKS:
    foreach my $linkarray (@links) {
      $pm->start and next LINKS; # do the fork
  
      my ($link, $fn) = @$linkarray;
      warn "Cannot get $fn from $link"
        if getstore($link, $fn) != RC_OK;
  
      $pm->finish; # do the exit in the child process
    }
    $pm->wait_all_children;
  
  First you need to instantiate the ForkManager with the "new" constructor.
  You must specify the maximum number of processes to be created. If you
  specify 0, then NO fork will be done; this is good for debugging purposes.
  
  Next, use $pm->start to do the fork. $pm returns 0 for the child process,
  and child pid for the parent process (see also L<perlfunc(1p)/fork()>).
  The "and next" skips the internal loop in the parent process. NOTE:
  $pm->start dies if the fork fails.
  
  $pm->finish terminates the child process (assuming a fork was done in the
  "start").
  
  NOTE: You cannot use $pm->start if you are already in the child process.
  If you want to manage another set of subprocesses in the child process,
  you must instantiate another Parallel::ForkManager object!
  
  =head1 METHODS
  
  The comment letter indicates where the method should be run. P for parent,
  C for child.
  
  =over 5
  
  =item new $processes
  
  Instantiate a new Parallel::ForkManager object. You must specify the maximum
  number of children to fork off. If you specify 0 (zero), then no children
  will be forked. This is intended for debugging purposes.
  
  The optional second parameter, $tempdir, is only used if you want the
  children to send back a reference to some data (see RETRIEVING DATASTRUCTURES
  below). If not provided, it is set via a call to L<File::Temp>::tempdir().
  
  The new method will die if the temporary directory does not exist or it is not
  a directory.
  
  =item start [ $process_identifier ]
  
  This method does the fork. It returns the pid of the child process for
  the parent, and 0 for the child process. If the $processes parameter
  for the constructor is 0 then, assuming you're in the child process,
  $pm->start simply returns 0.
  
  An optional $process_identifier can be provided to this method... It is used by
  the "run_on_finish" callback (see CALLBACKS) for identifying the finished
  process.
  
  =item finish [ $exit_code [, $data_structure_reference] ]
  
  Closes the child process by exiting and accepts an optional exit code
  (default exit code is 0) which can be retrieved in the parent via callback.
  If the second optional parameter is provided, the child attempts to send
  it's contents back to the parent. If you use the program in debug mode
  ($processes == 0), this method just calls the callback.
  
  If the $data_structure_reference is provided, then it is serialized and
  passed to the parent process. See RETRIEVING DATASTRUCTURES for more info.
  
  =item set_max_procs $processes
  
  Allows you to set a new maximum number of children to maintain.
  
  =item wait_all_children
  
  You can call this method to wait for all the processes which have been
  forked. This is a blocking wait.
  
  =item max_procs 
  
  Returns the maximal number of processes the object will fork.
  
  =item running_procs
  
  Returns the pids of the forked processes currently monitored by the
  C<Parallel::ForkManager>. Note that children are still reported as running
  until the fork manager harvest them, via the next call to
  C<start> or C<wait_all_children>.
  
      my @pids = $pm->running_procs;
  
      my $nbr_children =- $pm->running_procs;
  
  =item wait_for_available_procs( $n )
  
  Wait until C<$n> available process slots are available.
  If C<$n> is not given, defaults to I<1>.
  
  =item waitpid_blocking_sleep 
  
  Returns the sleep period, in seconds, of the pseudo-blocking calls.
  Returns C<0> if disabled. 
  
  Defaults to 1 second.
  
  See I<BLOCKING CALLS> for more details.
  
  =item set_waitpid_blocking_sleep $seconds
  
  Sets the the sleep period, in seconds, of the pseudo-blocking calls.
  Set to C<0> to disable.
  
  See I<BLOCKING CALLS> for more details.
  
  =back
  
  =head1 CALLBACKS
  
  You can define callbacks in the code, which are called on events like starting
  a process or upon finish. Declare these before the first call to start().
  
  The callbacks can be defined with the following methods:
  
  =over 4
  
  =item run_on_finish $code [, $pid ]
  
  You can define a subroutine which is called when a child is terminated. It is
  called in the parent process.
  
  The parameters of the $code are the following:
  
    - pid of the process, which is terminated
    - exit code of the program
    - identification of the process (if provided in the "start" method)
    - exit signal (0-127: signal name)
    - core dump (1 if there was core dump at exit)
    - datastructure reference or undef (see RETRIEVING DATASTRUCTURES)
  
  =item run_on_start $code
  
  You can define a subroutine which is called when a child is started. It called
  after the successful startup of a child in the parent process.
  
  The parameters of the $code are the following:
  
    - pid of the process which has been started
    - identification of the process (if provided in the "start" method)
  
  =item run_on_wait $code, [$period]
  
  You can define a subroutine which is called when the child process needs to wait
  for the startup. If $period is not defined, then one call is done per
  child. If $period is defined, then $code is called periodically and the
  module waits for $period seconds between the two calls. Note, $period can be
  fractional number also. The exact "$period seconds" is not guaranteed,
  signals can shorten and the process scheduler can make it longer (on busy
  systems).
  
  The $code called in the "start" and the "wait_all_children" method also.
  
  No parameters are passed to the $code on the call.
  
  =back
  
  =head1 BLOCKING CALLS
  
  When it comes to waiting for child processes to terminate, C<Parallel::ForkManager> is between 
  a fork and a hard place (if you excuse the terrible pun). The underlying Perl C<waitpid> function
  that the module relies on can block until either one specific or any child process 
  terminate, but not for a process part of a given group.
  
  This means that the module can do one of two things when it waits for 
  one of its child processes to terminate:
  
  =over
  
  =item Only wait for its own child processes
  
  This is done via a loop using a C<waitpid> non-blocking call and a sleep statement.
  The code does something along the lines of
  
      while(1) {
          if ( any of the P::FM child process terminated ) {
              return its pid
          }
  
          sleep $sleep_period
      }
  
  This is the default behavior that the module will use.
  This is not the most efficient way to wait for child processes, but it's
  the safest way to ensure that C<Parallel::ForkManager> won't interfere with 
  any other part of the codebase. 
  
  The sleep period is set via the method C<set_waitpid_blocking_sleep>.
  
  =item Block until any process terminate
  
  Alternatively, C<Parallel::ForkManager> can call C<waitpid> such that it will
  block until any child process terminate. If the child process was not one of
  the monitored subprocesses, the wait will resume. This is more efficient, but mean
  that C<P::FM> can captures (and discards) the termination notification that a different
  part of the code might be waiting for. 
  
  If this is a race condition
  that doesn't apply to your codebase, you can set the 
  I<waitpid_blocking_sleep> period to C<0>, which will enable C<waitpid> call blocking.
  
      my $pm = Parallel::ForkManager->new( 4 );
  
      $pm->set_waitpid_blocking_sleep(0);  # true blocking calls enabled
  
      for ( 1..100 ) {
          $pm->start and next;
  
          ...; # do work
  
          $pm->finish;
      }
  
  =back
  
  =head1 RETRIEVING DATASTRUCTURES from child processes
  
  The ability for the parent to retrieve data structures is new as of version
  0.7.6.
  
  Each child process may optionally send 1 data structure back to the parent.
  By data structure, we mean a reference to a string, hash or array. The
  contents of the data structure are written out to temporary files on disc
  using the L<Storable> modules' store() method. The reference is then
  retrieved from within the code you send to the run_on_finish callback.
  
  The data structure can be any scalar perl data structure which makes sense:
  string, numeric value or a reference to an array, hash or object.
  
  There are 2 steps involved in retrieving data structures:
  
  1) A reference to the data structure the child wishes to send back to the
  parent is provided as the second argument to the finish() call. It is up
  to the child to decide whether or not to send anything back to the parent.
  
  2) The data structure reference is retrieved using the callback provided in
  the run_on_finish() method.
  
  Keep in mind that data structure retrieval is not the same as returning a
  data structure from a method call. That is not what actually occurs. The
  data structure referenced in a given child process is serialized and
  written out to a file by L<Storable>. The file is subsequently read back
  into memory and a new data structure belonging to the parent process is
  created. Please consider the performance penality it can imply, so try to
  keep the returned structure small.
  
  =head1 EXAMPLES
  
  =head2 Parallel get
  
  This small example can be used to get URLs in parallel.
  
    use Parallel::ForkManager;
    use LWP::Simple;
  
    my $pm = Parallel::ForkManager->new(10);
  
    LINKS:
    for my $link (@ARGV) {
      $pm->start and next LINKS;
      my ($fn) = $link =~ /^.*\/(.*?)$/;
      if (!$fn) {
        warn "Cannot determine filename from $fn\n";
      } else {
        $0 .= " " . $fn;
        print "Getting $fn from $link\n";
        my $rc = getstore($link, $fn);
        print "$link downloaded. response code: $rc\n";
      };
      $pm->finish;
    };
  
  =head2 Callbacks
  
  Example of a program using callbacks to get child exit codes:
  
    use strict;
    use Parallel::ForkManager;
  
    my $max_procs = 5;
    my @names = qw( Fred Jim Lily Steve Jessica Bob Dave Christine Rico Sara );
    # hash to resolve PID's back to child specific information
  
    my $pm = Parallel::ForkManager->new($max_procs);
  
    # Setup a callback for when a child finishes up so we can
    # get it's exit code
    $pm->run_on_finish( sub {
        my ($pid, $exit_code, $ident) = @_;
        print "** $ident just got out of the pool ".
          "with PID $pid and exit code: $exit_code\n";
    });
  
    $pm->run_on_start( sub {
        my ($pid, $ident)=@_;
        print "** $ident started, pid: $pid\n";
    });
  
    $pm->run_on_wait( sub {
        print "** Have to wait for one children ...\n"
      },
      0.5
    );
  
    NAMES:
    foreach my $child ( 0 .. $#names ) {
      my $pid = $pm->start($names[$child]) and next NAMES;
  
      # This code is the child process
      print "This is $names[$child], Child number $child\n";
      sleep ( 2 * $child );
      print "$names[$child], Child $child is about to get out...\n";
      sleep 1;
      $pm->finish($child); # pass an exit code to finish
    }
  
    print "Waiting for Children...\n";
    $pm->wait_all_children;
    print "Everybody is out of the pool!\n";
  
  =head2 Data structure retrieval
  
  In this simple example, each child sends back a string reference.
  
    use Parallel::ForkManager 0.7.6;
    use strict;
  
    my $pm = Parallel::ForkManager->new(2, '/server/path/to/temp/dir/');
  
    # data structure retrieval and handling
    $pm -> run_on_finish ( # called BEFORE the first call to start()
      sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
  
        # retrieve data structure from child
        if (defined($data_structure_reference)) {  # children are not forced to send anything
          my $string = ${$data_structure_reference};  # child passed a string reference
          print "$string\n";
        }
        else {  # problems occuring during storage or retrieval will throw a warning
          print qq|No message received from child process $pid!\n|;
        }
      }
    );
  
    # prep random statement components
    my @foods = ('chocolate', 'ice cream', 'peanut butter', 'pickles', 'pizza', 'bacon', 'pancakes', 'spaghetti', 'cookies');
    my @preferences = ('loves', q|can't stand|, 'always wants more', 'will walk 100 miles for', 'only eats', 'would starve rather than eat');
  
    # run the parallel processes
    PERSONS:
    foreach my $person (qw(Fred Wilma Ernie Bert Lucy Ethel Curly Moe Larry)) {
      $pm->start() and next PERSONS;
  
      # generate a random statement about food preferences
      my $statement = $person . ' ' . $preferences[int(rand @preferences)] . ' ' . $foods[int(rand @foods)];
  
      # send it back to the parent process
      $pm->finish(0, \$statement);  # note that it's a scalar REFERENCE, not the scalar itself
    }
    $pm->wait_all_children;
  
  A second datastructure retrieval example demonstrates how children decide
  whether or not to send anything back, what to send and how the parent should
  process whatever is retrieved.
  
  =for example begin
  
    use Parallel::ForkManager 0.7.6;
    use Data::Dumper;  # to display the data structures retrieved.
    use strict;
  
    my $pm = Parallel::ForkManager->new(20);  # using the system temp dir $L<File::Temp::tempdir()
  
    # data structure retrieval and handling
    my %retrieved_responses = ();  # for collecting responses
    $pm -> run_on_finish (
      sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
  
        # see what the child sent us, if anything
        if (defined($data_structure_reference)) {  # test rather than assume child sent anything
          my $reftype = ref($data_structure_reference);
          print qq|ident "$ident" returned a "$reftype" reference.\n\n|;
          if (1) {  # simple on/off switch to display the contents
            print &Dumper($data_structure_reference) . qq|end of "$ident" sent structure\n\n|;
          }
  
          # we can also collect retrieved data structures for processing after all children have exited
          $retrieved_responses{$ident} = $data_structure_reference;
        } else {
          print qq|ident "$ident" did not send anything.\n\n|;
        }
      }
    );
  
    # generate a list of instructions
    my @instructions = (  # a unique identifier and what the child process should send
      {'name' => '%ENV keys as a string', 'send' => 'keys'},
      {'name' => 'Send Nothing'},  # not instructing the child to send anything back to the parent
      {'name' => 'Childs %ENV', 'send' => 'all'},
      {'name' => 'Child chooses randomly', 'send' => 'random'},
      {'name' => 'Invalid send instructions', 'send' => 'Na Na Nana Na'},
      {'name' => 'ENV values in an array', 'send' => 'values'},
    );
  
    INSTRUCTS:
    foreach my $instruction (@instructions) {
      $pm->start($instruction->{'name'}) and next INSTRUCTS;  # this time we are using an explicit, unique child process identifier
  
      # last step in child processing
      $pm->finish(0) unless $instruction->{'send'};  # no data structure is sent unless this child is told what to send.
  
      if ($instruction->{'send'} eq 'keys') {
        $pm->finish(0, \join(', ', keys %ENV));
  
      } elsif ($instruction->{'send'} eq 'values') {
        $pm->finish(0, [values %ENV]);  # kinda useless without knowing which keys they belong to...
  
      } elsif ($instruction->{'send'} eq 'all') {
        $pm->finish(0, \%ENV);  # remember, we are not "returning" anything, just copying the hash to disc
  
      # demonstrate clearly that the child determines what type of reference to send
      } elsif ($instruction->{'send'} eq 'random') {
        my $string = q|I'm just a string.|;
        my @array = qw(I am an array);
        my %hash = (type => 'associative array', synonym => 'hash', cool => 'very :)');
        my $return_choice = ('string', 'array', 'hash')[int(rand 3)];  # randomly choose return data type
        $pm->finish(0, \$string) if ($return_choice eq 'string');
        $pm->finish(0, \@array) if ($return_choice eq 'array');
        $pm->finish(0, \%hash) if ($return_choice eq 'hash');
  
      # as a responsible child, inform parent that their instruction was invalid
      } else {
        $pm->finish(0, \qq|Invalid instructions: "$instruction->{'send'}".|);  # ordinarily I wouldn't include invalid input in a response...
      }
    }
    $pm->wait_all_children;  # blocks until all forked processes have exited
  
    # post fork processing of returned data structures
    for (sort keys %retrieved_responses) {
      print qq|Post processing "$_"...\n|;
    }
  
  =for example end
  
  =head1 BUGS AND LIMITATIONS
  
  Do not use Parallel::ForkManager in an environment, where other child
  processes can affect the run of the main program, so using this module
  is not recommended in an environment where fork() / wait() is already used.
  
  If you want to use more than one copies of the Parallel::ForkManager, then
  you have to make sure that all children processes are terminated, before you
  use the second object in the main program.
  
  You are free to use a new copy of Parallel::ForkManager in the child
  processes, although I don't think it makes sense.
  
  =head1 COPYRIGHT
  
  =encoding utf8
  
  Copyright (c) 2000-2010 Szab, Balzs (dLux)
  
  All right reserved. This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
    dLux (Szab, Balzs) <dlux@dlux.hu>
  
  =head1 CREDITS
  
    Gbor Szab (szabgab@cpan.org)  (co-maintainer)
    Michael Gang (bug report)
    Noah Robin <sitz@onastick.net> (documentation tweaks)
    Chuck Hirstius <chirstius@megapathdsl.net> (callback exit status, example)
    Grant Hopwood <hopwoodg@valero.com> (win32 port)
    Mark Southern <mark_southern@merck.com> (bugfix)
    Ken Clarke <www.perlprogrammer.net>  (datastructure retrieval)
  
  =cut
  
  package Parallel::ForkManager;
  use POSIX ":sys_wait_h";
  use Storable qw(store retrieve);
  use File::Spec;
  use File::Temp ();
  use File::Path ();
  use Carp;
  
  use strict;
  use vars qw($VERSION);
  $VERSION="1.12";
  $VERSION = eval $VERSION;
  
  sub new {
    my ($c,$processes,$tempdir)=@_;
  
    my $h={
      max_proc   => $processes,
      processes  => {},
      in_child   => 0,
      parent_pid => $$,
      auto_cleanup => ($tempdir ? 0 : 1),
      waitpid_blocking_sleep => 1,
    };
  
  
    # determine temporary directory for storing data structures
    # add it to Parallel::ForkManager object so children can use it
    # We don't let it clean up so it won't do it in the child process
    # but we have our own DESTROY to do that.
    if (not defined($tempdir) or not length($tempdir)) {
      $tempdir = File::Temp::tempdir(CLEANUP => 0);
    }
    die qq|Temporary directory "$tempdir" doesn't exist or is not a directory.| unless (-e $tempdir && -d _);  # ensure temp dir exists and is indeed a directory
    $h->{tempdir} = $tempdir;
  
    return bless($h,ref($c)||$c);
  };
  
  sub start {
    my ($s,$identification)=@_;
  
    die "Cannot start another process while you are in the child process"
      if $s->{in_child};
    while ($s->{max_proc} && ( keys %{ $s->{processes} } ) >= $s->{max_proc}) {
      $s->on_wait;
      $s->wait_one_child(defined $s->{on_wait_period} ? &WNOHANG : undef);
    };
    $s->wait_children;
    if ($s->{max_proc}) {
      my $pid=fork();
      die "Cannot fork: $!" if !defined $pid;
      if ($pid) {
        $s->{processes}->{$pid}=$identification;
        $s->on_start($pid,$identification);
      } else {
        $s->{in_child}=1 if !$pid;
      }
      return $pid;
    } else {
      $s->{processes}->{$$}=$identification;
      $s->on_start($$,$identification);
      return 0; # Simulating the child which returns 0
    }
  }
  
  sub finish {
    my ($s, $x, $r)=@_;
  
    if ( $s->{in_child} ) {
      if (defined($r)) {  # store the child's data structure
        my $storable_tempfile = File::Spec->catfile($s->{tempdir}, 'Parallel-ForkManager-' . $s->{parent_pid} . '-' . $$ . '.txt');
        my $stored = eval { return &store($r, $storable_tempfile); };
  
        # handle Storables errors, IE logcarp or carp returning undef, or die (via logcroak or croak)
        if (not $stored or $@) {
          warn(qq|The storable module was unable to store the child's data structure to the temp file "$storable_tempfile":  | . join(', ', $@));
        }
      }
      CORE::exit($x || 0);
    }
    if ($s->{max_proc} == 0) { # max_proc == 0
      $s->on_finish($$, $x ,$s->{processes}->{$$}, 0, 0, $r);
      delete $s->{processes}->{$$};
    }
    return 0;
  }
  
  sub wait_children {
    my ($s)=@_;
  
    return if !keys %{$s->{processes}};
    my $kid;
    do {
      $kid = $s->wait_one_child(&WNOHANG);
    } while $kid > 0 || $kid < -1; # AS 5.6/Win32 returns negative PIDs
  };
  
  *wait_childs=*wait_children; # compatibility
  
  sub wait_one_child {
    my ($s,$par)=@_;
  
    my $kid;
    while (1) {
      $kid = $s->_waitpid(-1,$par||=0);
      last if $kid == 0 || $kid == -1; # AS 5.6/Win32 returns negative PIDs
      redo if !exists $s->{processes}->{$kid};
      my $id = delete $s->{processes}->{$kid};
  
      # retrieve child data structure, if any
      my $retrieved = undef;
      my $storable_tempfile = File::Spec->catfile($s->{tempdir}, 'Parallel-ForkManager-' . $$ . '-' . $kid . '.txt');
      if (-e $storable_tempfile) {  # child has option of not storing anything, so we need to see if it did or not
        $retrieved = eval { return &retrieve($storable_tempfile); };
  
        # handle Storables errors
        if (not $retrieved or $@) {
          warn(qq|The storable module was unable to retrieve the child's data structure from the temporary file "$storable_tempfile":  | . join(', ', $@));
        }
  
        # clean up after ourselves
        unlink $storable_tempfile;
      }
  
      $s->on_finish( $kid, $? >> 8 , $id, $? & 0x7f, $? & 0x80 ? 1 : 0, $retrieved);
      last;
    }
    $kid;
  };
  
  sub wait_all_children {
    my ($s)=@_;
  
    while (keys %{ $s->{processes} }) {
      $s->on_wait;
      $s->wait_one_child(defined $s->{on_wait_period} ? &WNOHANG : undef);
    };
  }
  
  *wait_all_childs=*wait_all_children; # compatibility;
  
  sub max_procs { $_[0]->{max_proc}; }
  
  sub running_procs {
      my $self = shift;
  
      my @pids = keys %{ $self->{processes} };
      return @pids;
  }
  
  sub wait_for_available_procs {
      my( $self, $nbr ) = @_;
      $nbr ||= 1;
  
      croak "nbr processes '$nbr' higher than the max nbr of processes (@{[ $self->max_procs ]})"
          if $nbr > $self->max_procs;
  
      $self->wait_one_child until $self->max_procs - $self->running_procs >= $nbr;
  }
  
  sub run_on_finish {
    my ($s,$code,$pid)=@_;
  
    $s->{on_finish}->{$pid || 0}=$code;
  }
  
  sub on_finish {
    my ($s,$pid,@par)=@_;
  
    my $code=$s->{on_finish}->{$pid} || $s->{on_finish}->{0} or return 0;
    $code->($pid,@par);
  };
  
  sub run_on_wait {
    my ($s,$code, $period)=@_;
  
    $s->{on_wait}=$code;
    $s->{on_wait_period} = $period;
  }
  
  sub on_wait {
    my ($s)=@_;
  
    if(ref($s->{on_wait}) eq 'CODE') {
      $s->{on_wait}->();
      if (defined $s->{on_wait_period}) {
          local $SIG{CHLD} = sub { } if ! defined $SIG{CHLD};
          select undef, undef, undef, $s->{on_wait_period}
      };
    };
  };
  
  sub run_on_start {
    my ($s,$code)=@_;
  
    $s->{on_start}=$code;
  }
  
  sub on_start {
    my ($s,@par)=@_;
  
    $s->{on_start}->(@par) if ref($s->{on_start}) eq 'CODE';
  };
  
  sub set_max_procs {
    my ($s, $mp)=@_;
  
    $s->{max_proc} = $mp;
  }
  
  sub set_waitpid_blocking_sleep {
      my( $self, $period ) = @_;
      $self->{waitpid_blocking_sleep} = $period;
  }
  
  sub waitpid_blocking_sleep {
      $_[0]->{waitpid_blocking_sleep};
  }
  
  sub _waitpid { # Call waitpid() in the standard Unix fashion.
      my( $self, $pid, $flag ) = @_;
  
      return $flag ? $self->_waitpid_non_blocking : $self->_waitpid_blocking;
  }
  
  sub _waitpid_non_blocking {
      my $self = shift;
  
      for my $pid ( $self->running_procs ) {
          my $p = waitpid $pid, &WNOHANG or next;
          if ( $p == -1 ) {
              warn "child process '$pid' disappeared. A call to `waitpid` outside of Parallel::ForkManager might have reaped it.\n";
              # it's gone. let's clean the process entry
              delete $self->{processes}{$pid};
          }
          else {
              return $pid;
          }
      }
  
      return 0;
  }
  
  sub _waitpid_blocking {
      my $self = shift;
  
      # pseudo-blocking
      if( my $sleep_period = $self->{waitpid_blocking_sleep} ) {
          while() {
              my $pid = $self->_waitpid_non_blocking;
              return $pid if $pid;
  
              sleep $sleep_period;
          }
      }
  
      return waitpid -1, 0;
  }
  
  sub DESTROY {
    my ($self) = @_;
  
    if ($self->{auto_cleanup} && $self->{parent_pid} == $$ && -d $self->{tempdir}) {
      File::Path::remove_tree($self->{tempdir});
    }
  }
  
  1;
PARALLEL_FORKMANAGER

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use v5.20;

#Core
use Parse::CPAN::Meta;
use IO::File;
use File::Path qw(make_path);
use Getopt::Long 'HelpMessage';
use autodie;
use experimental 'signatures';
use Pod::Usage;

#Non-standard
use List::Util qw/pairs/;
use Parallel::ForkManager;

if (!@ARGV) {
    pod2usage(-verbose => 1, -message => "$0: argument(s) required\n")
}

GetOptions(
    'output=s'      =>  \ (my $outputDir = "/scratch/uesu/out/assm.0100.out"), ## the output should be in scratch not network storage to keep network down
    'config=s'      =>  \ (my $configFile),
    'threads=i'     =>  \ (my $threads = 1),
    'type=s'        =>  \ (my $omic = "gDNA")
) or die "Invalid options passwed to $0\n";

die "$0 requires the license holder argument (--config)\n" unless $configFile;

say <<"LOG";
# output Directory:  $outputDir
# config file: $configFile
# num threads: $threads
# sequencing type: $omic
LOG


make_path($outputDir) unless -d $outputDir;

my $config = Parse::CPAN::Meta->load_file($configFile);
my $pm = Parallel::ForkManager->new($threads);

my @fqs = map { "$config->{fqFileDir}{$omic}{directory}/$_" } map {@$_} @{$config->{fqFileDir}{$omic}{lanes}};
my @annotations = map { "$config->{annotationDir}{$omic}{directory}/$_" } map {@$_} @{$config->{annotationDir}{$omic}{lanes}};
my @samples = map {($fqs[$_], $annotations[$_])} (0 .. $#annotations);

foreach my $pair (pairs @samples)
{
    my ($fq, $annotation) = @$pair;
    $pm->start and next;
    extraction($fq, $annotation, $omic, $outputDir);
    $pm->finish;
}
$pm->wait_all_children;

=head1 DESCRIPTION

=item extraction

 reads ko annotation output from blast2lca and splits fq file into KO binned fastQs

 Input:
    $fq - fastq file
    $annotation - blast2lca annotation file
    $omic - the type sequencing type cDNA or gDNA
    $outputDir - output directory

 Output

    Directory of fastq files split by KOs

=cut

sub extraction($fq, $annotation, $omic, $outputDir)
{
    say "reading fxnal annotation: $annotation and extracting from fq: $fq";
    my $prefix = (split("/",$fq))[-1];
    $prefix =~ s/\.fq$|\.fastq$//;
    my $koHash;
    my %fh;

    open(my $koAnnote, "<", $annotation);
    while(<$koAnnote>)
    {
        chomp;
        my ($readID, $ko) = split(/\t/);
        $koHash->{$readID} = $ko;
    }
    my $outputDir = "$outputDir/$omic/$prefix";
    make_path($outputDir) unless -d $outputDir;

    open(my $fastq, "<", $fq);
    while(my $readID = <$fastq>)
    {
        chomp $readID;
        $readID =~ s/^\@//;
        #say $readID;
        if (exists $koHash->{$readID})
        {
            #say "Found one";
            my $seq   = <$fastq>;
            my $h2    = <$fastq>;
            my $qual  = <$fastq>;
            my $ko    = $koHash->{$readID};
            $fh{$ko} = IO::File->new(">$outputDir/$ko") unless exists $fh{$ko};
            $fh{$ko}->print("@"."$readID\n$seq$h2$qual");
        }else{
            <$fastq>;<$fastq>;<$fastq>;
        }
    }
    $fh{$_}->close for keys %fh;
}

=head1 NAME

 clump takes the output from blast2lca and collects reads from the same KO bins into the same files

=head1 SYNOPSIS

  --annotation,-a   annotations directory must have same name as fq eg. s_1_1.filtered.fastq and s_1_1.filtered.ko.txt
  --output,-o          output dir
  --config,-c       json config file
  --threads,-p      number of threads
  --type,-t         gDNA or cDNA
  --help,-h         Print this help

=head1 VERSION

0.01

=cut

__DATA__
{
    "fqFileDir":
    {
        "gDNA":
        {
            "directory":"./fq",
            "lanes":[
                ["s_1_1.filtered.fastq", "s_1_2.filtered.fastq"],
                ["s_2_1.filtered.fastq", "s_2_2.filtered.fastq"]
            ]
        }
    },
    "annotationDir":
    {
        "gDNA":
        {
            "directory":"./annotations",
            "lanes": [
                ["s_1_1.filtered.ko.txt", "s_1_2.filtered.ko.txt"],
                ["s_2_1.filtered.ko.txt", "s_2_2.filtered.ko.txt"]
                ]
            }
    }
}
